#include "arduino_secrets.h"
/*This sketch takes a text input from an IoT broker and send to your boardThe input commands will turn the LED light of your board ON or OFF.Using the NB IOT network with a Telstra SIM, the MKR NB 1500 can be contacted from anywhereYou can send the input command remotelyWritten by DeveloperSteve, edited by Michelle2Minhye May 2020 For CallForCode May 2020 */// libraries#include <MKRNB.h>#include <PubSubClient.h>//The MKRNB lib needs this even if its blankconst char PINNUMBER[]     = "";//define secret stuff//see secret tab to populate these with values from your IBM Watson IoT clientchar token[] = SECRET_TOKEN; //your secret token copied when adding devicechar ORG[] = SECRET_ORG; //the prefix of your watson iot dashboard URLchar DEVICE_TYPE = SECRET_DEVICE_TYPE; //you defined when adding devicechar DEVICE_ID - SECRET_DEVICE_ID; //you defined when adding device//find these in the Watson IoT client// #define token "INSERT_YOURS_HERE"// #define ORG "INSERT_YOURS_HERE"// #define DEVICE_TYPE "INSERT_YOURS_HERE"// #define DEVICE_ID "INSERT_YOURS_HERE"//broker url in here, demo is using eclipse test serverchar mqttBroker[]  = ORG ".messaging.internetofthings.ibmcloud.com";//broker port in hereint mqttPort = 1883;char authMethod[] = "use-token-auth";char clientId[] = "d:" ORG ":" DEVICE_TYPE ":" DEVICE_ID;//subscribe to the pubsub watson iot topic. make sure you define the input format you expect (in this case, text)const char topicSubscribe[] = "iot-2/cmd/default/fmt/text";// initialize the library instanceNBClient client;GPRS gprs;NB nbAccess;//connect the pubsub clientPubSubClient conn(client);//for the callbacks from the brokervoid callback(char* topic, byte* payload, unsigned int length) {    //the input comes one char at a time, make sure they are concantenated  char p[length + 1];  memcpy(p, payload, length);  p[length] = NULL;  String msg(p);    //print message to serial monitor  Serial.print("Message arrived [");  Serial.print(topic);  Serial.println("] ");  Serial.println(msg);    //we expect the user to send ON or OFF  //the section of code for controlling LED is taken from the blink test sketch  if(msg=="on"){    digitalWrite(LED_BUILTIN, HIGH);  } else if ( msg == "off") {    digitalWrite(LED_BUILTIN, LOW);  }}//connection and reconnection function void reconnect() {    while (!conn.connected()) {    // Attemp to connect    if (conn.connect(clientId, authMethod, token)) {      Serial.println("Connected");      conn.subscribe(topicSubscribe);    } else {      Serial.print("Failed, rc=");      Serial.print(conn.state());      Serial.println(" try again in 2 seconds");            // Wait 2 seconds before retrying      delay(2000);    }  }}void setup() {    // initialize serial communications and wait for port to open:  Serial.begin(9600);  //  while (!Serial) {//    ; // wait for serial port to connect. Needed for native USB port only//  }pinMode(LED_BUILTIN, OUTPUT);  Serial.println("Warming up....");    // connection state  boolean connected = false;  while (!connected) {    if ((nbAccess.begin(PINNUMBER) == NB_READY) &&        (gprs.attachGPRS() == GPRS_READY)) {      connected = true;    } else {      Serial.println("Not connected");      delay(1000);    }  }  Serial.println("connecting...");    //set the connection  conn.setServer(mqttBroker, mqttPort);    //set the callback   conn.setCallback(callback);    //subscribe to a topic   conn.subscribe(topicSubscribe);}void loop() {  if (!conn.connected()) {    reconnect();  }  conn.loop();}